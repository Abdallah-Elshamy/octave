% test jsondecode

failed_tests_num = 0;

%% Test 1: decode null values

% null, in nonnumeric arrays to Empty double []
try
  json = '["str", 5, null, true]';
  exp  = {'str'; 5; []; true};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 1 failed\n');
  failed_tests_num +=1;
end_try_catch

% null, in numeric arrays to NaN
try
  json = '[1, 2, null, 3]';
  exp  = [1; 2; NaN; 3];
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 2 failed\n');
  failed_tests_num +=1;
end_try_catch

% corner case: array of null values
try
  json = '[null, null, null]';
  exp  = [NaN; NaN; NaN];
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 3 failed\n');
  failed_tests_num +=1;
end_try_catch

%% Test 2: decode Boolean, Number and String values
try
  assert (jsondecode ('true'));
catch
  printf('test 4 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  assert (~ jsondecode ('false'));
catch
  printf('test 5 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  act  = jsondecode ('123.45');
  assert (isequal (123.45, act));
catch
  printf('test 6 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  act  = jsondecode ('"hello there"');
  assert (isequal ('hello there', act));
catch
  printf('test 7 failed\n');
  failed_tests_num +=1;
end_try_catch

%% Test 3: decode Array of Booleans, Numbers and Strings values
try
  json = '[true, true, false, true]';
  exp  = [1; 1; 0; 1];
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 8 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '["true", "true", "false", "true"]';
  exp  = {'true'; 'true'; 'false'; 'true'};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 9 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '["foo", "bar", ["foo", "bar"]]';
  exp  = {'foo'; 'bar'; {'foo'; 'bar'}};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 10 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[15000, 5, 12.25, 1502302.3012]';
  exp  = [15000; 5; 12.25; 1502302.3012];
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 11 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[[1,2]]';
  exp  = [1 2];
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 12 failed\n');
  failed_tests_num +=1;
end_try_catch

% If they have the same dimensions -> transform to an array
try
  json = '[[1, 2], [3, 4]]';
  exp  = [1 2; 3 4];
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 13 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]';
  exp  = cat (3, [1, 3; 5, 7], [2, 4; 6, 8]);
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 14 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[[true, false], [true, false], [true, false]]';
  exp  = [1 0; 1 0; 1 0];
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 15 failed\n');
  failed_tests_num +=1;
end_try_catch

% If they have different dimensions -> transform to a cell array
try
  json = '[[1, 2], [3, 4, 5]]';
  exp  = {[1; 2]; [3; 4; 5]};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 16 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[1, 2, [3, 4]]';
  exp  = {1; 2; [3; 4]};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 17 failed\n');
  failed_tests_num +=1;
end_try_catch

try
  json = '[true, false, [true, false, false]]';
  exp  = {1; 0; [1; 0; 0]};
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 18 failed\n');
  failed_tests_num +=1;
end_try_catch

%% Test 4: decode JSON objects

% check the decoding of Boolean, Number and String values inside an object
try
  json = '{"number": 3.14, "string": "string", "boolean": false}';
  exp  = struct ('number', 3.14, 'string', 'string', 'boolean', 0);
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 19 failed\n');
  failed_tests_num +=1;
end_try_catch

% check the decoding of null values and arrays inside an object & makeValidName
try
  json = '{"nonnumeric array": ["str", 5, null], "numeric array": [1, 2, null]}';
  exp  = struct ('nonnumericArray',{{'str'; 5; []}}, 'numericArray', {[1; 2; NaN]});
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 20 failed\n');
  failed_tests_num +=1;
end_try_catch

%  check the decoding of objects inside an object & makeValidName
try
  json = '{"object": {"  field 1   ": 1, "field-   2": 2, "3field": 3, "": 1}}';
  exp  = struct ('object', struct ('field1', 1, 'field_2', 2, 'x3field', 3, 'x', 1));
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 21 failed\n');
  failed_tests_num +=1;
end_try_catch

%  check the decoding of empty objects, empty arrays and Inf inside an object
try
  json = '{"a": Inf, "b": [], "c": {}}';
  exp  = struct ('a', Inf, 'b', [], 'c', struct ());
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 22 failed\n');
  failed_tests_num +=1;
end_try_catch

% check the decoding of string arrays inside an object & makeValidName
try
  json = '{"%string.array": ["Statistical","Parametric","Mapping"]}';
  exp  = struct ('x_string_array', {{'Statistical'; 'Parametric'; 'Mapping'}});
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 23 failed\n');
  failed_tests_num +=1;
end_try_catch

% a big test
try
  json = ['{' , ...
      '"glossary": { ', ...
          '"title": "example glossary",', ...
  		'"GlossDiv": {', ...
              '"title": "S",', ...
  			'"GlossList": {', ...
                  '"GlossEntry": {', ...
                      '"ID": "SGML",', ...
  					'"SortAs": "SGML",', ...
  					'"GlossTerm": "Standard Generalized Markup Language",', ...
  					'"Acronym": "SGML",', ...
  					'"Abbrev": "ISO 8879:1986",', ...
  					'"GlossDef": {', ...
                          '"para": "A meta-markup language, ', ...
                          'used to create markup languages such as DocBook.",', ...
  						'"GlossSeeAlso": ["GML", "XML"]', ...
                      '},', ...
  					'"GlossSee": "markup"', ...
                  '}', ...
              '}', ...
          '}', ...
      '}', ...
  '}'];
  tmp1 = struct ('para', ['A meta-markup language, used to create markup languages', ...
                 ' such as DocBook.'],'GlossSeeAlso', {{'GML'; 'XML'}});
  tmp2 = struct ('ID', 'SGML', 'SortAs', 'SGML', 'GlossTerm', ...
                 'Standard Generalized Markup Language', 'Acronym', 'SGML', ...
                 'Abbrev', 'ISO 8879:1986', 'GlossDef', tmp1, 'GlossSee', 'markup');
  exp  = struct ('glossary', struct ('title', 'example glossary', 'GlossDiv', ...
                  struct ('title', 'S', 'GlossList', struct ('GlossEntry', tmp2))));
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 24 failed\n');
  failed_tests_num +=1;
end_try_catch

%% Test 5: decode Array of JSON objects

% arrays with the same field names in the same order
try
  json = '{"structarray": [{"a":1,"b":2},{"a":3,"b":4}]}';
  exp  = struct ('structarray', struct ('a', {1; 3}, 'b', {2; 4}));
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 25 failed\n');
  failed_tests_num +=1;
end_try_catch

% arrays with the same field names in the same order and a big test
try
  json = ['[', ...
    '{', ...
      '"_id": "5ee28980fc9ab3",', ...
      '"index": 0,', ...
      '"guid": "b229d1de-f94a",', ...
      '"latitude": -17.124067,', ...
      '"longitude": -61.161831,', ...
      '"friends": [', ...
        '{', ...
          '"id": 0,', ...
          '"name": "Collins"', ...
        '},', ...
        '{', ...
          '"id": 1,', ...
          '"name": "Hays"', ...
        '},', ...
        '{', ...
          '"id": 2,', ...
          '"name": "Griffin"', ...
        '}', ...
      ']', ...
    '},', ...
    '{', ...
      '"_id": "5ee28980dd7250",', ...
      '"index": 1,', ...
      '"guid": "39cee338-01fb",', ...
      '"latitude": 13.205994,', ...
      '"longitude": -37.276231,', ...
      '"friends": [', ...
        '{', ...
          '"id": 0,', ...
          '"name": "Osborn"', ...
        '},', ...
        '{', ...
          '"id": 1,', ...
          '"name": "Mcdowell"', ...
        '},', ...
        '{', ...
          '"id": 2,', ...
          '"name": "Jewel"', ...
        '}', ...
      ']', ...
    '},', ...
    '{', ...
      '"_id": "5ee289802422ac",', ...
      '"index": 2,', ...
      '"guid": "3db8d55a-663e",', ...
      '"latitude": -35.453456,', ...
      '"longitude": 14.080287,', ...
      '"friends": [', ...
        '{', ...
          '"id": 0,', ...
          '"name": "Socorro"', ...
        '},', ...
        '{', ...
          '"id": 1,', ...
          '"name": "Darla"', ...
        '},', ...
        '{', ...
          '"id": 2,', ...
          '"name": "Leanne"', ...
        '}', ...
      ']', ...
    '}', ...
  ']'];
  tmp1 = struct ('id', {0; 1; 2}, 'name', {'Collins'; 'Hays'; 'Griffin'});
  tmp2 = struct ('id', {0; 1; 2}, 'name', {'Osborn'; 'Mcdowell'; 'Jewel'});
  tmp3 = struct ('id', {0; 1; 2}, 'name', {'Socorro'; 'Darla'; 'Leanne'});
  exp  = struct ('_id', {'5ee28980fc9ab3'; '5ee28980dd7250'; '5ee289802422ac'}, ...
                 'index', {0; 1; 2}, 'guid', {'b229d1de-f94a'; '39cee338-01fb'; '3db8d55a-663e'}, ...
                 'latitude', {-17.124067; 13.205994; -35.453456}, 'longitude', ...
                 {-61.161831; -37.276231; 14.080287}, 'friends', {tmp1; tmp2; tmp3});
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 26 failed\n');
  failed_tests_num +=1;
end_try_catch

% arrays with the same field names in different order
try
  json = '{"cellarray": [{"a":1,"b":2},{"b":3,"a":4}]}';
  exp  = struct ('cellarray', {{struct('a', 1, 'b', 2); struct('b', 3, 'a', 4)}});
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 27 failed\n');
  failed_tests_num +=1;
end_try_catch

% arrays with different field names
try
  json = '{"cellarray": [{"a":1,"b":2},{"a":3,"c":4}]}';
  exp  = struct ('cellarray', {{struct('a', 1, 'b', 2); struct('a', 3, 'c', 4)}});
  act  = jsondecode (json);
  assert (isequal (exp, act));
catch
  printf('test 28 failed\n');
  failed_tests_num +=1;
end_try_catch

% arrays with different field names and a big test
try
  json = ['[', ...
    '{', ...
      '"_id": "5ee28980fc9ab3",', ...
      '"index": 0,', ...
      '"guid": "b229d1de-f94a",', ...
      '"latitude": -17.124067,', ...
      '"longitude": -61.161831,', ...
      '"friends": [', ...
        '{', ...
          '"id": 0,', ...
          '"name": "Collins"', ...
        '},', ...
        '{', ...
          '"id": 1,', ...
          '"name": "Hays"', ...
        '},', ...
        '{', ...
          '"id": 2,', ...
          '"name": "Griffin"', ...
        '}', ...
      ']', ...
    '},', ...
    '{"numeric array": ["str", 5, null], "nonnumeric array": [1, 2, null]},', ...
    '{', ...
       '"firstName": "John",', ...
       '"lastName": "Smith",', ...
       '"age": 25,', ...
       '"address":', ...
       '{', ...
           '"streetAddress": "21 2nd Street",', ...
           '"city": "New York",', ...
           '"state": "NY"', ...
       '},', ...
       '"phoneNumber":', ...
           '{', ...
             '"type": "home",', ...
             '"number": "212 555-1234"', ...
           '}', ...
   '}]'];
  tmp1 =  struct ('_id', '5ee28980fc9ab3', 'index', 0, 'guid', 'b229d1de-f94a', ...
                  'latitude', -17.124067, 'longitude', -61.161831, 'friends', ...
                 struct ('id', {0; 1; 2}, 'name', {'Collins'; 'Hays'; 'Griffin'}));
  tmp2 = struct ('numericArray',{{'str'; 5; []}}, 'nonnumericArray', {[1; 2; NaN]});
  tmp3 = struct ('firstName', 'John','lastName', 'Smith', 'age', 25, 'address', ...
                 struct('streetAddress', '21 2nd Street', 'city', 'New York', 'state', 'NY'), ...
                 'phoneNumber', struct ('type', 'home', 'number', '212 555-1234'));
  exp = {tmp1; tmp2; tmp3};
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 29 failed\n');
  failed_tests_num +=1;
end_try_catch

%% Test 6: decode Array of different JSON data types
try
  json = ['[null, true, Inf, 2531.023, "hello there", ', ...
    '{', ...
      '"_id": "5ee28980dd7250",', ...
      '"index": 1,', ...
      '"guid": "39cee338-01fb",', ...
      '"latitude": 13.205994,', ...
      '"longitude": -37.276231,', ...
      '"friends": [', ...
        '{', ...
          '"id": 0,', ...
          '"name": "Osborn"', ...
        '},', ...
        '{', ...
          '"id": 1,', ...
          '"name": "Mcdowell"', ...
        '},', ...
        '{', ...
          '"id": 2,', ...
          '"name": "Jewel"', ...
        '}', ...
      ']', ...
    '}]'];
  tmp =  struct ('_id', '5ee28980dd7250', 'index', 1, 'guid', '39cee338-01fb', ...
                  'latitude', 13.205994, 'longitude', -37.276231, 'friends', ...
                  struct ('id', {0; 1; 2}, 'name', {'Osborn'; 'Mcdowell'; 'Jewel'}));
  exp = {[]; 1; Inf; 2531.023; 'hello there'; tmp};
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 30 failed\n');
  failed_tests_num +=1;
end_try_catch

% Array of arrays
try
  json = ['[["str", Inf, null], [1, 2, null], ["foo", "bar", ["foo", "bar"]],', ...
    '[[[1, 2], [3, 4]], [[5, 6], [7, 8]]],' , ...
    '[', ...
      '{', ...
        '"_id": "5ee28980fc9ab3",', ...
        '"index": 0,', ...
        '"guid": "b229d1de-f94a",', ...
        '"latitude": -17.124067,', ...
        '"longitude": -61.161831,', ...
        '"friends": [', ...
          '{', ...
            '"id": 0,', ...
            '"name": "Collins"', ...
          '},', ...
          '{', ...
            '"id": 1,', ...
            '"name": "Hays"', ...
          '},', ...
          '{', ...
            '"id": 2,', ...
            '"name": "Griffin"', ...
          '}', ...
        ']', ...
      '},', ...
      '{"numeric array": ["str", 5, null], "nonnumeric array": [1, 2, null]},', ...
      '{', ...
         '"firstName": "John",', ...
         '"lastName": "Smith",', ...
         '"age": 25,', ...
         '"address":', ...
         '{', ...
             '"streetAddress": "21 2nd Street",', ...
             '"city": "New York",', ...
             '"state": "NY"', ...
         '},', ...
         '"phoneNumber":', ...
             '{', ...
               '"type": "home",', ...
               '"number": "212 555-1234"', ...
             '}', ...
     '}]]'];
  tmp1 = struct ('_id', '5ee28980fc9ab3', 'index', 0, 'guid', 'b229d1de-f94a', ...
                 'latitude', -17.124067, 'longitude', -61.161831, 'friends', ...
                 struct ('id', {0; 1; 2}, 'name', {'Collins'; 'Hays'; 'Griffin'}));
  tmp2 = struct ('numericArray',{{'str'; 5; []}}, 'nonnumericArray', {[1; 2; NaN]});
  tmp3 = struct ('firstName', 'John','lastName', 'Smith', 'age', 25, 'address', ...
                    struct('streetAddress', '21 2nd Street', 'city', 'New York', 'state', 'NY'), ...
                    'phoneNumber', struct ('type', 'home', 'number', '212 555-1234'));
  exp = {{'str'; Inf; []}; [1; 2; NaN]; {'foo'; 'bar'; {'foo'; 'bar'}};
         cat(3, [1, 3; 5, 7], [2, 4; 6, 8]); {tmp1; tmp2 ;tmp3}};
  act  = jsondecode (json);
  assert (isequaln (exp, act));
catch
  printf('test 31 failed\n');
  failed_tests_num +=1;
end_try_catch

printf('%d tests failed out of 31 test\n',failed_tests_num);
